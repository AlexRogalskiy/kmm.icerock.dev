---
sidebar_position: 9
---

# Логирование и обработка ошибок

## Логирование

Рассмотрим ситуацию, в которой бы мы не заботились о логировании на протяжении всей работы над проектом. Успешно его завершили, протестировали и отдали заказчику.
Спустя какое-то время, после того как приложением начали пользоваться, получаем сообщение от заказчика, что пользователи жалуются на то, что у них бессистемно крашится приложение.

Мы начинаем искать ошибки и причины краша приложения. Все, что нам о них известно - что они происходят на нескольких экранах без какой-либо системы.  
Попробовали воспроизвести ошибки - не получилось. Проверили код нескольких проблемных экранов - тоже вроде бы все в порядке, проблемные места обработаны.  
Остается последний вариант - пробовать воспроизводить ошибки, чтобы определить, в каком месте и по какой причине они происходят. Всей командой пытаемся добиться краша приложения, но у нас все работает, ни одного краша за целый день.
Наконец, спустя еще N времени кому-нибудь удалось достичь краша, который затем исправили силами одного разработчика за 30 минут.  

Согласитесь, бороться таким образом с каждой ошибкой - не самый хороший вариант. 

Чтобы избежать этого, мы используем сервис [Firebase Crashlytics](https://firebase.google.com/docs/crashlytics), который позволяет получать данные обо всех ошибках, которые произошли у пользователей на устройствах, без какого-либо участия с их стороны.  
Сервис позволяет ловить два вида ошибок:
  - `fatal` - произошел прям краш приложения
  - `non-fatal` - произошла ошибка, однако, она была как-то обработана (`try catch`)

Как реагировать на `fatal` и `non-fatal` ошибки:
- fatal:
  - раз приложение крашнулось, значит где-то произошла ошибка, которая никак не обрабатывается. 
    Наши действия: добавим обработчик ошибок в то место, где она произошла, и добавим логирование в `Firebase Crashlytics`, чтобы все следующие ошибки в этом месте попадали в `Firebase`, но уже как `non-fatal`
- non-fatal:
  - раз произошла `non-fatal` ошибка, значит проблемное место мы уже обрабатываем и логируем
  
Рассмотрим `non-fatal` ошибки подробнее. Какими они бывают:
  - это новая ошибка, которая произошла из-за косяка в нашем коде
  - это стандартная ошибка, например, из-за отсутствия интернета или из-за нехватки памяти на устройстве, чтобы сохранить файл

Если ошибка произошла из-за какого-то недочета в коде - мы просто исправим код и все.  

Если же эта ошибка стандартная - мы изменим условие логирования, чтобы больше не видеть информацию об этой ошибке в `Firebase`.
Это поможет нам избавиться от информации о куче `non-fatal` ошибок, и, когда произойдет какая-то новая ошибка, мы сразу это заметим и пойдем разбираться, а не пропустим ее в общей куче ошибок.

Теперь, когда нам снова напишет заказчик и сообщит, что у юзеров опять крашится приложение, наш план будет следующим:
- открываем `Firebase Crashlytics` и видим, какая ошибка происходит у пользователей
- оперативно исправляем ошибку

Для логирования в общем коде мы используем библиотеку [Napier](https://github.com/AAkira/Napier), которую связываем с `Firebase Crashlytics`, чтобы через `Napier` логи автоматически попадали и в `Crashlytics`.

Поэтому при разработке нового проекта логи проставляются как минимум во всех обработчиках ошибок.

Также, если заранее удается понять, что какая-то информация каждого конкретного запуска приложения может пригодиться для последующего исправления ошибки, ее следует логировать с уровнем `INFO`.
Однако, никакие секретные ключи и пароли логировать нельзя.


## Обработка ошибок в общем коде

В любом мобильном приложении часто происходят нефатальные ошибки, направленные на обратную связь, например: отсутствие интернет соединения, нехватка памяти на устройстве для загрузки данных, различные ответы сервера и т.д. Обо всем этом нужно корректно доносить пользователю.  
Такие ошибки, как правило, показываются юзеру как алерт или тост, чтобы юзер успел посмотреть, в чем проблема, и попробовал решить ее самостоятельно. 

Мы в IceRock используем для этого библиотеку [moko-errors](https://github.com/icerockdev/moko-errors).  
С ее помощью мы можем:
- централизованно обрабатывать все ошибки общего кода
- выбрать, как показывать ошибку юзеру - через `Toast`, `Alert` или иначе
- Использовать разные строки для разных ошибок, прямо в общем коде

Разберем компоненты этой библиотеки:

`ExceptionMappersStorage` - в нем мы регистрируем всю логику того, как из `Exception` получить текстовое описание ошибки, чтобы во всей логике во всех фичах не задумываться о том, какой текст выдать для каждой ошибки.
Мы просто в нужном месте вызываем маппер, который вернет необходимую строку.

`ExceptionMappersStorage` имеет возможность установки текста:
- для конкретной ошибки
- для всех ошибок, удовлетворяющих какому-нибудь условию
- текст по умолчанию - "Неизвестная ошибка", уже задан в проекте-шаблоне

Если вы знаете, какие ошибки могут произойти в вашем приложении, - регистрируйте их в маппере.

## Практическое задание

- склонируйте себе moko-errors
- запустите sample, посмотрите, как он работает на обеих платформах
- добавьте `alertErrorPresenter`, настройте, проверьте, как он работает 
- добавьте свой класс ошибки, по аналогии с `CustomException`, добавьте свою строку локализации для отображения информации об этой ошибке, убедитесь, что все работает на обеих платформах
- склонируйте себе mobile-moko-boilerplate, посмотрите, как создается `ExceptionMappersStorage` и функция `createExceptionHandler`, как она прокидывается до вьюмодели 
