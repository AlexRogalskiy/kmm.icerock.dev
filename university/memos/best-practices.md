---
sidebar_position: 0
---

# Best Practices

## Введение
На этой странице перечислены наиболее распространенные ошибки, которые, как правило, новички повторяют не один раз, что существенно увеличивает время ревью.    
Однако, большинство из этих ошибок совсем не сложные и их легко заметить и исправить самостоятельно.    
Это позволит существенно сократить время прохождения ревью и быстрее стать крутым разработчиком ;)  

Для самопроверки, обращайтесь к тому разделу, которым вы сейчас занимаетесь.  

## Общее
1. Продумывайте имена функций и их содержимое, [памятка](function)
2. Не пытайтесь реализовать то, что уже есть в системе. Если что-то в дизайне немного отличается от системного варианта (`Alert`, `Toolbar`, кнопка "назад") - спросите у руководителя, действительно ли должно 1 в 1 быть как в дизайне. 99%, что системная реализация подходит
3. Не должно быть никакого хардкода текста, который показывается пользователю, надо использовать строки локализации
4. Не работайте с сетевыми сущностями в приложении, преобразуйте их в свои - доменные сущности и используйте их во всем приложении
   - если в приложении вы работаете с сетевыми сущностями, то в случае, если на сервере что-то изменят, например изменят имя какого-то поля или поменяют вложенность полей, то вам придется исправлять все места, где используется эта сущность. А если при получении сетевой сущности вы сразу преобразуете(маппите) ее в доменную, то при изменении сетевой вам нужно будет просто изменить функцию-маппер.
   - если от сервера где-то приходит `null` вы можете как-то заменить на `not-null` значение, чтобы удобнее работать в приложении. Например, если приходит поле `description = null` - в маппере можно заменить на пустую строку
5. Следите за неймингом! У вас не должно быть переменных и методов, которые не несут в названии никакой информации о том, для чего они предназначены
   - например: `binding.button.setOnCLickListener { buttonClickAction() }` - ни кнопка, ни метод не несут абсолютно никакой информации о том, к чему они относятся
6. Используйте автоформатирование после изменения каждого файла
   - `Option` + `Command` + `L` (Android Studio)
   - `Control` + `i` (Xcode)
7. Если вы используете `State` и `Actions`, то в названии переменных обязательно должно фигурировать, что это `state` или `actions`
8. ***Начиная с 4ого блока*** новые зависимости добавляйте сразу в [libs.versions.toml](../../learning/gradle/version-catalogs), в нужный блок.
9. ***Начиная с 4ого блока*** Не используйте `MR` ресурсы на платформе, на андроид есть `R`, на iOS есть `R.swift`.
   - в мультиплатформенных ресурсах должны быть только те, которые управляются общей логикой. Те ресурсы, которые ей не управляются - должны находиться на платформе. ***ссылка на четвертый блок, где будет пояснение).***
10. Не создавайте дополнительную переменную, если она никак не улучшает читаемость кода
11. Не допускайте сильной вложенности кода (избегайте callback hell)
    - используйте ранний возврат
    - разбивайте большие функции на вызов функций поменьше
    - `somethingButton.setOnClickListener(::somethingButtonPressed)` - устанавливайте действие на клик одной функцией, не пишите логику сразу в `setOnClickListener`
12. Максимально настраивайте статический UI элемент в `.xml` или `.xib`, чтобы не заниматься его настройкой в коде
13. Не используйте форскасты. О том, когда их действительно нужно использовать вы поймете, когда дорастёте до мидла :)
14. Разделяйте классы/интерфейсы/объекты по файлам, как указано в [кодстайле](../../learning/code-style/separate-by-files)
15. Проверяйте по [кодстайлу](../../learning/code-style/it-in-lambdas) все то, что вы написали
16. Кликабельные элементы UI не должны сами решать, какой метод вьюмодели им вызывать
    - `exitButton.setOnClickListener { viewModel.clearUserData() }` - UI не должен говорить вьюмодели - чисти данные пользователя
    - `exitButton.setOnClickListener { viewModel.onExitButtonPressed() }` - UI должен говорить вьюмодели - нажата кнопка `exitButton`, т.е. публичное API вьюмодели должно быть таким, чтобы по нему явно было понятно, когда его использовать 
17. Используйте аннотации [@Throws](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throws/) только в случае, если это попадает в swift код
18. Используйте [weakLambda](../../learning/libraries/moko/moko-units#можно-ли-передавать-лямбду-в-unititem) - позволяет сохранять `receiver` слабой ссылкой
19. Проверяйте, что не загрузили в гит всякую фигню, [настройте](https://kmm.icerock.dev/university/memos/gitignore) `.gitignore`
20. Код не должен содержать никаких дебажных `print` и закомменченных строк, которые не несут никакой смысловой нагрузки
21. Данные из `KeyValueStorage` не должны сохраняться в свойства класса, каждый раз надо обращаться к `KeyValueStorage` и получать актуальное значение
22. Кастомные `Exceptions`, которые вы сами кидаете, наследуйте от `RuntimeException()`, либо от более конкретных его наследников. Также, не забывайте прокидывать в родителя `cause` реально произошедшей ошибки, чтобы потом увидеть ее в `stackTrace`
23. Расставляйте элементы UI в `xml` в порядке отрисовки, а не вразнобой
    - те элементы, которые находятся сверху экрана (`Toolbar`) объявляйте сверху в `xml` 
    - не забывайте, что объявленные "выше" элементы могут перекрываться элементами, объявленными ниже в `xml`
24. Не забывайте про конфликты имен Kotlin и iOS
    - если у вас в common коде будет свойство `description`, [вот](../../learning/kotlin-multiplatform/mobile-highlights#конфликты-имен-на-ios) как оно будет доступно на iOS
    - одинаковые имена переменных в двух разных интерфейсах
    - функции с одинаковыми именами аргументов, но разными типами
    - классы с одинаковым именем, но в разных пакетах
25. Связь UI с `viewModel` должна полностью находиться в функции `bindToViewModel`
    - функция `bindToViewModel` должна быть легкочитаема, поэтому должна вызывать другие функции, которые связывают конкретный UI элемент с `viewModel`
26. Не создавайте лишние функции, действия внутри которых итак понятны, без функции, например
27. Константы должны иметь явное название, чтобы по имени было понятно, для чего они нужны 
    - плохо `const val REPO_NAME = "repo_name"` 
    - хорошо `const val REPO_NAME_ARG_KEY = "repo_name"`
28. Не надо выдавать никакие данные из юнита (например по клику)
    - по клику на юнит он должен просто информировать наружу - "на меня нажали"
29. Не создавайте общий класс констант - рано или поздно получится свалка, константы должны создаваться именно там, где они имеют смысл
30. Никогда не обрабатывайте `Error`-ы. у `Throwable` два наследника - `Exception` и `Error`. Эксепшены надо обрабатывать, они исправимы. а `Error`-ы - неисправимы, их обрабатывать не надо, приложение должно упасть с информацией о том чего пошло не так (в `Error` эта информация)
    - изучите [документацию](https://rollbar.com/blog/java-exceptions-hierarchy-explained/) 

## iOS
### Logic
1. Все аутлеты должны быть приватными
2. Обрабатывайте стейты на iOS правильно ***Ссылка про стейты на iOS***
3. Не забывайте про [циклы](../../learning/memory_management) сильных ссылок, используйте `weak self` там, где он нужен
   - плохо
     ```
     cell.onTap = {
       self.navigationController?...
     }
     ```
   - хорошо
     ```swift
     cell.onTap = { [weak self] in
       self?.navigationController?...
     }
     ```
4. Сплешскрин делать в `LaunchScreen.storyboard`, а не в `SplashViewController`
5. Чтобы у кнопки "Назад" не было текста - нужно у предыдущего экрана выставить в `navigationItem.backButtonTitle = ""` - `navController` берет название для кнопки "Назад" от того экрана, на который будет производиться переход назад
6. Ключи в классах всегда `private static let` - потому что ключи не уникальные для конкретного экземпляра класса
7. Обязательно устанавливайте в `Podfile` версии подов, их можно посмотреть после установки подов в файле `Podfile.lock`. Если версии подов не будут явно обозначены - то у нового разработчика, или у тебя (на другом компе) при установке подов могут подтянуться более новые версии. Есть вероятность, что в этих новых подах что-то будет изменено и проект не скомпилируется. Либо, как сейчас популярно, в библиотеку всунут зловредный код в новой версии он тоже скачается :)
8. Все `ViewController`-ы должны называться с окончанием `ViewController`, а не `Screen`, потому что `Screen`- это экран девайса. `ViewController` не обязательно занимает весь экран, их на экране сразу несколько: твой собственный, `UINavigationController`, `UITabBarController`, модалки

### UI
1. Если какой-то одинаковый набор элементов используется сразу на нескольких экранах - выносите его в отдельную кастомную `UIView` и используйте на нужных экранах
   - добавление кастомных вьюх должно быть не через код, а через `Interface builder`
2. Добавляйте текст вьюхам, чтобы легче ориентироваться на дизайне экрана. Не добавляйте такой текст, который должен быть в готовом приложении, чтобы потом не забыть поменять. 
   - например, для названия кнопки ввода используйте не "Ввод", а "//Ввод", тогда, если бы вы забыли заменить этот текст, то сразу бы увидели это при запуске приложения
3. Проверяйте имя файла картинки, которую скачали с `Figma`, оно должно явно обозначать, что это за картинка, аналогично с неймингом переменных
   - векторные картинки должны быть `single scale`
4. Если фон во всем приложении одинаковый - устанавливайте его правильно
   - вариант 1: установить в `AppDelegate`, `navigationController?.navigationBar.barStyle = .black` - сразу после создания контроллера устанавливаем цвет 
   - вариант 2: в `.plist` установите `UIViewControllerBasedStatusBarAppearance = NO` и `Status bar is initially hidden = NO`, тогда вообще не придется устанавливать `navigationBar.barStyle = .black`

## Android
### Logic
1. Обрабатывайте стейты на Android [правильно](../../learning/android/states-events#обработка)
2. Используйте конструкцию `with(binding...)` для `XML` элементов правильно. Не стоит ей злоупотреблять, иначе она будет только ухудшать читаемость.
   - не стоит использовать `binding`
      ```kotlin
      private fun setToolBar() {
          with(binding.toolbar) {
              navigationIcon = AppCompatResources.getDrawable(
                  requireContext(),
                  R.drawable.arrow_back
              )
              setNavigationOnClickListener {
                  findNavController().navigateUp()
              }
              setOnMenuItemClickListener { menuItem ->
                  when (menuItem.itemId) {
                      R.id.action_logout -> {
                          viewModel.onLogoutPressed()
                          true
                      }
                      else -> {
                          false
                      }
                  }
              }
          }
      }
      ```
   - стоит использовать `binding`
      ```kotlin
      with(binding.view1.subview1.subsubview1) {
          label1.text = TODO()
          button1.setOnClickListener { TODO() }
          image1.imageAlpha = TODO()
          view11.subview1.button1.setOnClickListener { TODO() }
          view11.subview2.button2.setOnClickListener { TODO() }
      }
      ```
3. Если в вашем приложении есть логика по выбору стартовой навигации, не забывайте использовать `savedInstanceState`, чтобы не создавать граф навигации заново
   - убедитесь, что установили граф в `activity_main.xml`
4. Аргументы фрагмента нужно получать через `requireArguments()`, если какого-то аргумента нет - кидать ошибку, что нет конкретного аргумента
   - используйте вычисляемые свойства для работы с аргументами: `private val something: String get() = requireArguments().getString(SOMETHING_KEY) ?: throw NoArgumentsException(lostArgument: SOMETHING_KEY)`
5. Подписка вью на вьюмодель должна создаваться сразу, как только мы их создали, в методе `onViewCreated`
6. Тема приложения должна выставляться в `AndroidManifest`, а не в `Activity` и `Fragment`-ах
7. Во `Fragment`-ах корутины нужно запускать во `viewLifecycleScope`, а не `lifecycleScope`. То есть цепляться ко вьюхе, а не к фрагменту
8. Не запутайтесь с удалением `Observer`:
   - так ничего не удалится
     ```kotlin
     private val request = MutableLiveData<...>()
     request.observeForever {
         if (it != null) {
             ...
         }
     }
     request.removeObserver { }
     ```
   - а вот так удалится
     ```kotlin
     private val request = MutableLiveData<...>()
     private val requestObserver: Observer<...?> = Observer { ... }
     request.removeObserver(requestObserver)
     ```
9. ***На чистом `Android`*** при работе со списками не забывайте смотреть [сюда](../../learning/android/adapter)
10. Используйте `lateinit` правильно
    - `lateinit` - это чисто андроидная штука, костыль, чтобы передавать компоненты во фрагменты и активити. Нужна потому что мы не можем создать кастомный класс фрагмента или активити, чтобы передавать зависимости сразу в конструктор. Мы даже не можем точно предсказать место, где будет создан объект фрагмента/активити. Поэтому `lateinit` - это костыль, которого нужно избегать, потому что `lateinit` переменную можно забыть проинитить и приложение крашнется
11. Настраивайте `Toolbar` правильно 
    - чтобы полностью взять на себя настройку `Toolbar` - укажите тему `NoActionBar` и, вместо `ActionBar`-а системного, используйте `Toolbar` - UI элемент который полностью тобой управляется. Также, у него есть встроенная интеграция с `Navigation Component`
12. Константы класса должны находиться в `сompanion object`, а в свойствах должно быть все то, что уникально для каждого экземпляра класса

### UI
1. Используйте константы для отступов в приложении правильно:
   - если дизайнер обозначил, что есть общие значения для некоторых отступов и т.д. - используйте константы
   - если обозначения общих размеров и отступов нет - использование констант на свой страх и риск (не рекомендуется)
   - констант не должно быть слишком много, иначе они будут только путать
   - именоваться константы должны относительно контекста использования - `background_color`, `status_bar_color`, `button_color_default`, `default_top_margin` и т.д.
2. Если какой-то набор элементов используется на нескольких экранах - выносите его в отдельный `.xml` и подключайте с помощью [include](https://developer.android.com/training/improving-layouts/reusing-layouts)
3. Используйте [tools:text](https://developer.android.com/studio/write/tool-attributes)
   - во всех UI элементах, которые содержат поле `text`, устанавливайте текст используя `tools:text`, чтобы было легче ориентироваться в дизайне экрана
4. Избегайте вложенности при использовании `ConstraintLayout`
   - главная цель `ConstraintLayout` в том, чтобы не использовать вложение в `LinearLayout` для расположения элементов на экране. Нужно это, во-первых, для улучшения производительности, потому что при большой вложенности `layout` друг в друга она сильно падает. Во-вторых, для более удобной верстки и улучшения читаемости `xml`
5. Верстайте экран сверху вниз, констрейнты вьюхам устанавливайте относительно друг друга, а не привязывайте каждую к корневому `Layout`
   - если элемент всегда расположен внизу экрана - не надо цеплять его к верхнему элементу
   - чтобы убедиться, что ваши правила верстки правильные - проверяйте на экранах разного размера - большой, средний, маленький, для этого просто переключайте превью 
6. Не использовать `bias` для расположения элемента на экране
7. Не нужно изменять цвет у корневого `layout`, главный цвет приложения должен быть у окна, иначе он сразу будет делать overwrite всех пикселей на экране
8. Отступы всегда должны быть кратны ***4*** (8, 16, 24, 32), если в дизайне по-другому, задавайте вопросы
9. Используя свои стили, всегда наследуйтесь от дефолтного, чтобы не потерять его настройки
   - не указывайте размеры `width` и `height` в стилях
10. `xml` называйте аналогично названию класса
    - плохо: `DetailRepoInfoFragment` и `fragment_detail_repo`
    - хорошо: `DetailInfoFragment` и `detail_info_fragment`

## Перед отправкой на ревью
- После каждого коммита выделяйте 5-7 минут, чтобы отсмотреть все изменения, на наличие ошибок, перечисленных на этой странице  
- После создания итогового merge request, отсмотрите все сделанные в нем изменения. Благодаря тому, что вы проверяли их после каждого коммита, это не займет у вас слишком много времени.

Такая самопроверка не только позволит вам не допускать перечисленных ошибок в будущем, но и ускорит ревью вашего merge request, потому что в нем уже не будет части ошибок.
